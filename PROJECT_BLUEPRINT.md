# PROJECT BLUEPRINT: AI Assistant

<!-- Version: 1.1 -->

## 1. System Overview and Core Purpose

This document is the canonical source of truth for the architectural principles and governance of the AI Assistant project. It serves as a "constitution" for human developers and a "README for the AI," ensuring that all development and AI-driven actions are aligned with the core design philosophy.

The system is a command-line-native, persona-driven agent designed to assist with software development tasks. Its primary purpose is to provide a safe, reliable, and extensible framework for leveraging Large Language Models to perform complex, multi-step operations on a local file system.

---

## 2. Core Architectural Principles

The architecture is built on three foundational principles:

### 2.1. Persona-First Operation
The primary interface for quality and control is the **Persona System**. All complex tasks should be initiated through a specialized persona. This ensures that AI behavior is constrained, predictable, and follows a proven operational protocol, rather than relying on generic, ad-hoc prompting.

### 2.2. Decoupled Execution
A strict separation is maintained between **AI-driven analysis (thinking)** and **deterministic execution (doing)**. The AI's primary output for any task that modifies the system is a reviewable "Output Package." A separate, non-AI `executor` script then applies these changes. This provides a critical safety layer, enhances resilience, and improves auditability.

#### 2.2.1. Adversarial Validation
To enhance the safety of the "thinking" phase, the system employs an Adversarial Validation Chain. After an initial execution plan is generated, it is passed to a specialized, skeptical "critic" persona. This critic's sole purpose is to identify potential flaws, unstated assumptions, and risks in the plan. The resulting critique is then presented to the human operator alongside the plan, providing a deeper layer of analysis before any action is confirmed. This principle acts as an automated "red team" review for the AI's own logic.

### 2.3. Explicit Governance
The behavior and structure of the persona ecosystem are not arbitrary. They are governed by a set of explicit, machine-readable rules in `persona_config.yml`. All personas are validated against these rules, and a cryptographically signed `persona_manifest.yml` ensures the application's runtime understanding of its capabilities is never out of sync with the committed source code.

---

## 3. Persona Directory & Chain of Command

The persona ecosystem is a team of specialists with a clear hierarchy of responsibility.

-   **`_base/` & `_mixins/` (Foundations):** These are not user-facing personas. They are abstract base classes and mixins that provide foundational behaviors (e.g., collaborative dialogue vs. technical analysis) and universal standards (e.g., code generation format) to all other personas through inheritance.

-   **`core/` (The Architects & Managers):** This is the senior leadership team. These personas are responsible for high-level, cross-cutting concerns of the project itself. This includes system architecture (`csa-1`), documentation (`dca-1`), persona governance (`pa-1`), and the new **Project Manager & Orchestrator (`pmo-1`)**. The `pmo-1` acts as a meta-controller, managing long-running projects by orchestrating the execution of other specialist personas in a defined sequence.

-   **`patterns/` (The Specialists):** These are expert individual contributors who solve common, recurring software development problems. This includes debugging (`da-1`), security auditing (`sva-1`), and quality assurance (`qsa-1`). They are the primary "doers" for day-to-day tasks and are typically invoked by the `pmo-1` or directly by the user for one-shot tasks.

-   **`domains/` (The Domain Experts):** These are specialists with knowledge external to software engineering, such as finance or trading. They are brought in when a task requires specific, real-world domain expertise.

---

## 4. Data & State Contracts

The primary data contracts for the system are the **Output Package** and the **Project State File**.

### 4.1. The Output Package Structure

A standardized directory structure generated by the `ai --output-dir` command for discrete, one-shot tasks.

```
./[output_dir]/
├── manifest.json         # The machine-readable plan of action.
├── workspace/            # Contains the FULL content of all new or modified files.
└── summary.md            # A human-readable summary of the changes.
```

### 4.2. The `manifest.json` Schema

The `manifest.json` is the "blueprint for action" and the single source of truth for the `ai-execute` script.

-   **`version` (string):** The schema version of the manifest.
-   **`sessionId` (string):** A unique, timestamp-based ID for the generation run.
-   **`generated_by` (string):** The alias of the persona that created the plan.
-   **`actions` (array):** A sequential list of action objects to be executed.
    -   **`type` (string):** The action to perform (e.g., `create_branch`, `apply_file_change`).
    -   **`comment` (string):** The AI's "thought" or rationale for the action.
    -   **...other parameters:** Action-specific fields (e.g., `branch_name`, `path`, `message`).

### 4.3. The Project State File

The `PROJECT_STATE.md` file is the single source of truth for a long-running, multi-agent project. It is created and managed by the `pmo-1` persona.

-   **Purpose:** To maintain state across multiple, separate invocations of the `ai` command, enabling complex, multi-stage workflows.
-   **Structure:** A Markdown file containing key-value metadata (status, goal) and sections for project artifacts like `Requirements`, `Architecture`, and a `Project Plan` that defines the dependency chain for specialist personas.
